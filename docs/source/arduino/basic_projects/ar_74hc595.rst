.. _ar_74hc595:

2.4 Microchip - 74HC595
===========================

¡Bienvenido a este emocionante proyecto! En este proyecto, utilizaremos el chip 74HC595 para controlar un flujo luminoso de 8 LEDs.

Imagina activar este proyecto y ser testigo de un flujo hipnotizante de luz, como si un arcoíris chispeante saltara entre los 8 LEDs. Cada LED se iluminará uno por uno y se apagará rápidamente, mientras el siguiente LED continúa brillando, creando un efecto hermoso y dinámico.

Utilizando de manera ingeniosa el chip 74HC595, podemos controlar los estados de encendido y apagado de múltiples LEDs para lograr el efecto de flujo. Este chip tiene múltiples pines de salida que pueden conectarse en serie para controlar la secuencia de iluminación de los LEDs. Además, gracias a la capacidad de expansión del chip, podemos agregar fácilmente más LEDs al display de flujo, creando efectos aún más espectaculares.

**Componentes Necesarios**

Para este proyecto, necesitamos los siguientes componentes.

Es definitivamente conveniente comprar un kit completo, aquí está el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit de Inicio ESP32
        - 320+
        - |link_esp32_starter_kit|

También puedes comprarlos por separado en los enlaces a continuación.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÓN DE COMPONENTES
        - ENLACE DE COMPRA

    *   - :ref:`cpn_esp32_wroom_32e`
        - |link_esp32_wroom_32e_buy|
    *   - :ref:`cpn_esp32_camera_extension`
        - \-
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_74hc595`
        - |link_74hc595_buy|


**Pines Disponibles**

Aquí está una lista de los pines disponibles en la placa ESP32 para este proyecto.

.. list-table::
    :widths: 5 20 

    * - Pines Disponibles
      - IO13, IO12, IO14, IO27, IO26, IO25, IO33, IO32, IO15, IO2, IO0, IO4, IO5, IO18, IO19, IO21, IO22, IO23


**Esquemático**

.. image:: ../../img/circuit/circuit_2.4_74hc595_led.png
    :width: 600

* Cuando MR (pin10) está a nivel alto y CE (pin13) está a nivel bajo, los datos se ingresan en el flanco ascendente de SHcp y pasan al registro de memoria a través del flanco ascendente de SHcp. 
* Si los dos relojes están conectados juntos, el registro de desplazamiento siempre va un pulso antes que el registro de memoria. 
* Hay un pin de entrada de desplazamiento serial (DS), un pin de salida serial (Q7') y un botón de reinicio asíncrono (nivel bajo) en el registro de memoria. 
* El registro de memoria produce una salida de Bus con 8 bits paralelos y en tres estados. 
* Cuando OE está habilitado (nivel bajo), los datos en el registro de memoria se envían al bus(Q0 ~ Q7).

**Cableado**

.. image:: ../../img/wiring/2.4_74hc595_bb.png
    :width: 800


**Código**

.. note::

    * Abre el archivo ``2.4_74hc595.ino`` bajo la ruta de ``esp32-starter-kit-main\c\codes\2.4_74hc595``.
    * Después de seleccionar la placa (ESP32 Dev Module) y el puerto apropiado, haz clic en el botón **Subir**.
    * :ref:`unknown_com_port`
    
.. raw:: html

    <iframe src=https://create.arduino.cc/editor/sunfounder01/024e20bb-f9c6-4baf-bb27-cdf49eb91e9e/preview?embed style="height:510px;width:100%;margin:10px 0" frameborder=0></iframe>

Cuando termines de subir los códigos a la placa ESP32, podrás ver los LEDs encendiéndose uno tras otro.

**¿Cómo funciona?**

#. Declara un arreglo, almacena varios números binarios de 8 bits que se utilizan para cambiar el estado de trabajo de los ocho LEDs controlados por 74HC595.

    .. code-block:: arduino

        int datArray[] = {B00000000, B00000001, B00000011, B00000111, B00001111, B00011111, B00111111, B01111111, B11111111};

#. Función ``loop()``.

    .. code-block:: arduino

        void loop()
            {
                for(int num = 0; num <10; num++)
                {
                    digitalWrite(STcp,LOW); //Set ST_CP and hold low for as long as you are transmitting
                    shiftOut(DS,SHcp,MSBFIRST,datArray[num]);
                    digitalWrite(STcp,HIGH); //pull the ST_CPST_CP to save the data
                    delay(1000);
                }
            }


    * Itera a través de ``datArray[]``, enviando secuencialmente los valores binarios al registro de desplazamiento.
    * Los comandos ``digitalWrite(STcp, LOW)`` y ``digitalWrite(STcp, HIGH)`` aseguran los datos en el registro de almacenamiento.
    * La función ``shiftOut()`` envía los valores binarios desde ``datArray[]`` al registro de desplazamiento usando el pin de datos (DS) y el pin de reloj del registro de desplazamiento (SHcp). ``MSBFIRST`` significa moverse desde los bits más altos.
    * Luego crea una pausa de 1 segundo entre cada actualización del patrón de LEDs.
